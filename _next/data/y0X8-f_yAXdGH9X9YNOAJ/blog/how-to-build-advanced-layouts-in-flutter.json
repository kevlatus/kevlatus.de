{"pageProps":{"article":{"sys":{"id":"5fIkiMAu6yZqETNwPnz9al"},"date":"2021-01-20T00:00:00.000Z","title":"How to build advanced layouts in Flutter","slug":"how-to-build-advanced-layouts-in-flutter","content":"Can we position widgets within custom shapes in Flutter? Actually, the framework provides a solution for building any kind of layout logic using CustomChildLayouts. I will show you how to implement a CustomMultiChildLayout to center any widget within the slice of a circle. How to draw that slice using a CustomPainter is shown in [my previous article](https://www.kevlatus.de/blog/making-of-flutter-fortune-wheel) in this series. This example is relevant, since all widgets in Flutter are based on rectangular boxes with each slice actually having the following bounding box.\n\n![img-circle-slice-children](//images.ctfassets.net/8iljeer8gbww/3CZLieZlgcZsCwnwJaqquS/2d43f57ea7596faf98b2c6da246e9b29/img-circle-slice-children.png)\n\nTherefore, we cannot use widgets like `Center` or `Align` in this scenario, since they position relative to the bounding box. Time to introduce the `MultiChildLayoutDelegate`: a base class for providing your own layout logic by implementing the `performLayout(Size)` method. Within this method two tasks need to be performed:\n\n1. all children are given their box constraints\n1. the resulting boxes are positioned within the available bounds\n\nTo identify child widgets, the framework provides us with the `hasChild` method. In order for them to work properly, each child needs to be given an ID, which can be understood as the _role_ it takes within the layout. The following code shows how this is achieved using the `LayoutId` widget.\n\n```dart\nenum CircleSliceLayoutSlot {\n  Slice,\n  Child,\n}\n\nclass CircleSliceLayout extends StatelessWidget {\n  final Widget child;\n  final CircleSlice slice;\n\n  const CircleSliceLayout({this.slice, this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomMultiChildLayout(\n      delegate: CircleSliceLayoutDelegate(slice.angle),\n      children: [\n        LayoutId( // ⬅ ⬇\n          id: CircleSliceLayoutSlot.Slice,\n          child: slice,\n        ),\n        LayoutId( // ⬅ ⬇\n          id: CircleSliceLayoutSlot.Child,\n          child: Transform.rotate(\n            angle: slice.angle / 2,\n            child: child,\n          ),\n        ),\n      ],\n    );\n  }\n}\n```\n\nAn enum helps us to distinguish between the circle slice and its child widget, which makes the code more readable and maintainable, but you could also use raw values/constants. Now let's look at the `CircleSliceLayoutDelegate` implementation.\n\n```dart\nclass CircleSliceLayoutDelegate extends MultiChildLayoutDelegate {\n  final double angle;\n\n  CircleSliceLayoutDelegate(this.angle);\n\n  @override\n  void performLayout(Size size) {\n    Size sliceSize;\n    Size childSize;\n\n    if (hasChild(CircleSliceLayoutSlot.Slice)) {\n      sliceSize = layoutChild(\n        CircleSliceLayoutSlot.Slice,\n        BoxConstraints.tight(size),\n      );\n      positionChildCircleSliceLayoutSlot.Slice, Offset.zero);\n    }\n\n    if (hasChild(CircleSliceLayoutSlot.Child)) {\n      childSize = layoutChild(\n        CircleSliceLayoutSlot.Child,\n        BoxConstraints.loose(size),\n      );\n\n      final topRectVector = Math.Point(sliceSize.width / 2, 0.0);\n      final halfAngleVector = rotateVector(topRectVector, angle / 2);\n\n      positionChild(\n        CircleSliceLayoutSlot.Child,\n        Offset(\n          halfAngleVector.x - childSize.width / 2,\n          halfAngleVector.y - childSize.height / 2,\n        ),\n      );\n    }\n  }\n\n  @override\n  bool shouldRelayout(CircleSliceLayoutDelegate oldDelegate) {\n    return angle != oldDelegate.angle;\n  }\n}\n```\n\nWithin `performLayout`, we first search for the slice widget by its ID and expand its box constraints to fill the available bounds. The child widget is supposed to only take up space it actually needs, which can be achieved by using loose box constraints. Centering this box within the slice is the tricky part. The image below visualizes the math involved in finding the correct offset for the child.\n\n![img-circle-slice-layout-logic](//images.ctfassets.net/8iljeer8gbww/6l7cL1efVIq8CXIXJ0T6g5/868ca2a069d8b828ae3cde8f6b2df7fb/img-circle-slice-layout-logic.png)\n\nWe want to position the child widget on the line, which cuts a given slice in half. To achieve that, we start of with a vector that points to the center of the top edge of our bounding box starting from its top left. This ensures that the vector's length is half the circle's  radius. To actually point to the center of our slice, we need to rotate this vector by half the slice's angle, which gives us the blue vector in above illustration.. If you are interested in how the `rotateVector` works, you can find its implementation in [this package's Github repository](https://github.com/kevlatus/flutter_fortune_wheel/blob/main/lib/src/util/util.dart#L10). With the slice's center at hand, the child's offset can be retrieved by adjusting the center to the child's size. If you believe there is a simpler way to achieve the same result, I encourage you to send me a message or comment with your ideas about this problem; I am always glad to learn of new features and tricks.\n\nThe last aesthetic adjustment is a child widget's rotation. Since I use text children in the examples, it makes sense to run them along the vector's line. As can be seen in the first code sample, this is achieved by wrapping it in a `Transform.rotate` with half the slices angle. But for icons or other use cases no rotation or another angle might be necessary, so this is up to your use case.\n\nFinally, we can build a fortune wheel from individual slices, each having correctly centered children. This shows that CustomMultiChildLayouts do not necessarily be composed of many widgets and can also be used for describing complex parent-child relationships. If you have any questions about this example, feel free to reach out to me or consult the [MultiChildLayoutDelegate docs](https://api.flutter.dev/flutter/rendering/MultiChildLayoutDelegate-class.html). \n\nIn my next article in this series, we will make the wheel actually spin using animation curves. Until then, you can spin the wheel yourself by installing it from [pub.dev](https://pub.dev/packages/flutter_fortune_wheel).\n","tags":null}},"__N_SSG":true}